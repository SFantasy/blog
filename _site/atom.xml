<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Fantasy's Homepage]]></title>
  <link href="/atom.xml" rel="self"/>
  <link href="/"/>
  <updated>2013-04-11T22:43:35+08:00</updated>
  <id>/</id>
  <author>
    <name><![CDATA[fanTasy shAo]]></name>
    
  </author>
  <generator uri="http://sfantasy.github.com/">fantasy | blog</generator>

  
  <entry>
    <title type="html"><![CDATA[合并分支上的特定文件]]></title>
    <link href="/2013-04-git-merge-specified-file/"/>
    <updated>2013-04-08T21:08:00+08:00</updated>
    <id>/git-merge-specified-file</id>
    <content type="html"><![CDATA[<p><strong>问题</strong></p>

<p>虽然说<code>merge</code>在Git的使用中还是很常见的一个操作，但是以前只用过<code>git merge branchname</code>这样的命令，今天遇到了一个情况，是这样的：</p>

<p>在一个repository中，我需要在<code>master</code>分支里<code>merge</code>一个<code>gh-pages</code>分支中的文件，也就是说，使用合并另一个分支上的特定文件。</p>

<p><strong>解决办法</strong></p>

<p><a href="http://stackoverflow.com/questions/449541/how-do-you-merge-selective-files-with-git-merge">Stackoverflow</a>上提到了很多解决的办法，其中被采纳的答案中提到了两种，具体可以看前文给出的链接。不过我都没有尝试，因为accepted的answer并不是最好的，至少在这里是这样的。</p>

<pre><code>git checkout branchename path/to/file1 path/to/file2
git commit -m "'Merge' code from 'branchname' branch"
</code></pre>

<p>简单、实用，这就是我要找的答案。</p>

<blockquote><p>如果这是一趟旅行，誓要发现途中最美的景色。</p></blockquote>

<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prototype in JavaScript]]></title>
    <link href="/2013-03-javascript-prototype/"/>
    <updated>2013-03-28T20:00:00+08:00</updated>
    <id>/javascript-prototype</id>
    <content type="html"><![CDATA[<blockquote><p>In a purely prototypal pattern, we dispense with classes. We focus on the objects.</p></blockquote>

<p>这句话是蝴蝶书中的，意在JavaScript中没有传统的类继承(诸如C++, Java等)，而是使用的原型模型. 所以说JavaScript是一门基于原型的语言.</p>

<p>原型继承比类继承模型要简单：一个新对象可以继承一个旧对象的属性.</p>

<p>还是用<em>代码</em>来说话吧(import from <a href="http://stackoverflow.com/questions/572897/how-does-javascript-prototype-work">stackoveflow</a>)：</p>

<pre><code>// 先来定义一个对象
var Person = function (name) {
    this.name = name;
};
//
Person.prototype.getName = function () {
    return this.name;
};
// 创建一个新的Person类型的对象
var john = new Person("John");

console.log(john.getName());
# John

// 更改Person的原型
Person.prototype.sayMyName = function () {
    console.log('Hello, my name is ' + this.getName());
};
// 同时也更改了john这个对象中的方法
john.sayMyName();
# John
</code></pre>

<p>接下来，创建一个新的对象</p>

<pre><code>var Customer = function (name) {
  this.name = name;
};
// 将Customer的原型指向一个Person对象的实例
Customer.prototype = new Person();

var myCustomer = new Customer('Dream Inc.');
myCustomer.sayMyName();

// 为Customer对象添加新的方法
Customer.prototype.setAmountDue = function (amountDue) {
    this.amountDue = amountDue;
};

Customer.prototype.getAmountDue = function () {
    return this.amountDue;
};

// 测试一下
myCustomer.setAmountDue(2000);
console.log(myCustomer.getAmountDue());

// Error
john.setAmountDue(1000);
</code></pre>

<p>其实以上例子就已经构建了一个<em>原型链</em>：</p>

<pre><code>myCustomer [Customer的实例]
{ name: 'Dream Inc.' , amountDue: 2000 }

    Customer.prototype [Person的实例]
    { name: undefined,
      setAmountDue: [Function],
      getAmountDue: [Function] }

        Person.prototype 
        { getName: [Function], sayMyName: [Function] }
</code></pre>

<p>这种继承的方式就是JavaScript中<em>原型链</em>的继承方式.</p>

<h3>属性查找</h3>

<p>在这种通过原型链继承的方式中，属性是只在读取的时候发生<em>属性继承</em>的，而在写入属性值的时候是不会发生的.<br/>
也就是说，如果一个对象O从某个对象Q的原型继承而来，那么对象O中的属性P也是从Q中继承而来的，也就是所谓的属性继承，在O中设置了P的值，相当于在O中直接新建了一个P属性。<br/>
而在后续程序中用到这个P属性的时候，发现P在O中已经定义，就不会通过原型链向上追溯了.</p>

<h2>性能</h2>

<p>要尽量避免原型链过长带来的性能问题，因为如果一个属性在原型链的上端就需要通过原型链不断向上查找，特别的，如果一个属性不存在，那么查找这个属性就会悲剧的遍历整个原型链.</p>

<p>  --EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Several topics in Python]]></title>
    <link href="/2013-03-python-questions/"/>
    <updated>2013-03-24T13:30:00+08:00</updated>
    <id>/python-questions</id>
    <content type="html"><![CDATA[<p>这篇文章其实是紧接着<code>lambda</code>那篇的, 谈的内容也比较的杂.</p>

<h3>Everything is an Object</h3>

<p>我们经常会听到一句话-- <em>Everything in Python is an object</em>. 然后呢？如何理解这句话呢？</p>

<blockquote><p>Everything in Python is an object, and almost everything has attributes and methods.</p></blockquote>

<p>尽管在Python中，有些对象既没有属性，又没有方法(Tuple?!);并且不是所有的对象都可以子类化。但是我们可以这样理解：</p>

<blockquote><p>Everthing is an object in the sense that it can be assigned to a  variable or passed as an argument to a function.</p></blockquote>

<h3>Decorator</h3>

<p>我们先来看看decorator的形式</p>

<h4>无参数形式的decorator</h4>

<pre><code>@myDecorator
def f():
    ...

#实际上执行：
f = myDecorator(f)

#多个decorator

@A
@B
@C
def f():
    ...

#实际上执行：
f = A(B(C(f)))
</code></pre>

<h4>有参数形式的decorator</h4>

<pre><code>@myDecorator(arg)
def f():
    ...

#实际上执行：
f = myDecorator(arg)(f)
</code></pre>

<p>也就是说，如果是有参数的decorator，会先将该参数传入decorator获得一个不带参数的decorator.</p>

<h4>decorator函数的定义</h4>

<p>事实上，每个decorator都对应的是一个函数，用来处理后面的函数.</p>

<pre><code>#返回原函数对象:

def A(f):
    #处理函数f
    return f

@A
def f(args):pass

#返回新的函数对象:

def A(f):
    def new_f(args):
        # Add something
        return f(args)
    return new_f

@A
def f(args):pass

#更为通用的形式,使用动态参数，

def A(f):
    def new_f(*args, **argkw):
      # Add something
      return f(*args, **argkw)
    return new_f

@A
def f(args):pass
</code></pre>

<h4>decorator的作用?</h4>

<p>limodou提到了decorator与<a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">AOP</a>(Aspect-oritented Programming)有点类似,其实意思也就是：在不修改代函数源代码的情况下，通过装饰器来给程序动态添加一些功能的思想。</p>

<p>事实上，如果只是使用普通的函数也是能够提供这类功能的吧？！（如果你懂得我的意思的话）不过使用decodator又有一个好处，这样写的形式特简单、明了。就像<a href="http://blog.csdn.net/beckel/article/details/3585352">Bruce Eckel</a>的博文中讲的那样：</p>

<blockquote><p>我认为，decorator之所以产生如此大影响，就是因为其带着一点点语法糖的味道改变了人们思考程序设计的方式。</p></blockquote>

<h3>staticmethod, classmethod &amp; normalmethod</h3>

<p>分别对应的其实也就是<em>静态方法</em>,<em>类方法</em>和<em>普通对象方法</em><br/>
还是举一个stackoverflow上的例子：</p>

<pre><code>class A(object):
    def foo(self, x):
        print "executing foo(%s, %s)"%(self, x)

    @classmethod
    def class_foo(cls, x):
        print "executing class_foo(%s, %s)"%(cls, x)

    @staticmethod
    def static_foo(x):
        print "executing static_foo(%s)"%x

a = A()
</code></pre>

<p>对象<code>a</code>是<code>A</code>的一个实例，我们平时最常用的方法类型就是<em>普通对象方法</em>，对象作为第一个参数被隐式调用.</p>

<pre><code>a.foo(1)
# executing foo(&lt;__main__.A object at 0x1d63890&gt;, 1)
</code></pre>

<p>对于<em>类方法</em>而言，实例<code>a</code>的类被作为第一个参数被隐式调用.</p>

<pre><code>a.class_foo(1)
# executing class_foo(&lt;class '__main__.A'&gt;,1)
A.class_foo(1)
# executing class_foo(&lt;class '__main__.A'&gt;,1)
# 事实上，定义一个类方法，更多的用类而不是该类的实例去调用之
</code></pre>

<p>而对于<em>静态方法</em>来说，实例和类(对应<code>self</code>和<code>cls</code>)都不会被隐式传入.</p>

<pre><code>a.static_foo(1)
# executing static_foo(1)
</code></pre>

<p><code>a.foo</code>可以将<code>foo</code>函数绑定到<code>a</code>实例，因为其将<code>a</code>这个实例作为参数传入了<code>foo</code>,同样<code>a.class_foo</code>将<code>class_foo</code>绑定到了<code>A</code>这个类;但是<code>static_foo</code>却只是单纯的一个函数，因为它没有绑定任何实例或者类.关于这些，我们可以通过<code>print</code>来观察：</p>

<pre><code>print(a.foo)
&lt;bound method A.foo of &lt;__main__.A object at 0x1e0c450&gt;&gt;

print(a.class_foo)
&lt;bound method type.class_foo of &lt;class '__main__.A'&gt;&gt;

print(a.static_foo)
&lt;function static_foo at 0x1eccf50&gt;
</code></pre>

<h3>The Zen of Python</h3>

<pre><code># Open your interpreter:
&gt;&gt; import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
</code></pre>

<p>中文翻译版可见<a href="http://wiki.woodpecker.org.cn/moin/PythonZen">此处</a>, 啄木鸟社区的几位大牛的不同风格的翻译.</p>

<h2>Reference</h2>

<ul>
<li><a href="http://www.diveintopython.net">Dive into Python</a></li>
<li><a href="http://blog.donews.com/limodou/">limodou的学习记录</a></li>
</ul>


<blockquote><p>文中关于decorator部分有点乱,不过……我先去赶软件测试女博士的作业了 :-(</p></blockquote>

<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scope & Closure in JavaScript]]></title>
    <link href="/2013-03-javascript-closure/"/>
    <updated>2013-03-23T01:10:00+08:00</updated>
    <id>/javascript-closure</id>
    <content type="html"><![CDATA[<p>最近一直在关注@lifesinger的博客，以issues的形式写的，还是比较有创意，直接watch就可以"订阅"，免掉了RSS(如果我的GR中的各位大牛都用这种方式写博客倒也不错，也就不必伤感GR的关闭了)。<br/>
其中有一篇文章牵扯到了"原生"JavaScript和jQuery之间的话题，关于文章的内容，可以去拜读一下<a href="https://github.com/lifesinger/lifesinger.github.com/issues/126">原文</a>.</p>

<p>让我这种菜鸟眼前一亮的是：</p>

<blockquote><p>具体对 JavaScript 语言来说，会用就好。搞清楚数据类型、作用域、闭包、原型链等基本概念，足矣。再深入进去，对绝大部分人来说，除了能满足下心理上的优越感，对实际工作不会有任何实质性帮助。</p></blockquote>

<p>"不明觉厉"！我之前有一篇博文说到过自己是一个"野生"程序员，所以也来"研究"一下这些基本概念.</p>

<h2>作用域 Scope</h2>

<p>作用域的概念很简单:</p>

<blockquote><p><em>Scope</em> in a programming language controls the visibility and lifetimes of variables and parameters.</p></blockquote>

<p>举一个<a href="http://book.douban.com/subject/2994925/">JavaScript: the good part</a>里的例子:</p>

<pre><code>var foo = function () {
  var a = 3, b = 5;
  //      
  var bar = function () {
    var b = 7, c = 11;
    //
    a += b + c;
    // a = 21, b = 7, c = 11
  };
  // a = 3, b = 5, c undefined
  bar();
  // a = 21, b = 5
};
</code></pre>

<p>当然，这个例子还是有点简单了，理解起来应该没有任何问题.</p>

<pre><code>var x = 10;
function foo() {
  alert(x);
}
(function () {
  var x = 20;
  foo();
  // alert 10, not 20
}) ();
</code></pre>

<p>JavaScript函数运行在被定义的作用域中，而不是执行它们的作用域中. 所以即使调用<code>foo()</code>函数前又声明了一个变量<code>x</code>，变量还是会从<code>foo()</code>函数创建时的作用域中去查找<code>x</code>的值.</p>

<p>在StackOverFlow上看到一个关于作用域的<a href="http://stackoverflow.com/questions/500431/javascript-variable-scope">问题</a>，其中有个回答得到了572票:</p>

<pre><code>// a globally-scoped variable
var a=1;

// global scope
function one(){
    alert(a); 
}

// local scope
function two(a){
    alert(a);
}

// local scope again
function three(){
    var a = 3;
    alert(a);
}

// Intermediate: no such thing as block scope in javascript
// JavaScript不支持块级(block scope)作用域
// 如果支持，那么var a=4;的作用域将被局限在if这个语句块内
function four(){
    if(true){
        var a=4;
    }                               
    alert(a); // alerts '4', not the global value of '1'
}

// Intermediate: object properties
function Five(){
    this.a = 5;
}

// Advanced: closure
var six = function(){
    var foo = 6;

    return function(){
        // javascript "closure" means I have access to foo in here, 
        // because it is defined in the function in which I was defined.
        alert(foo);
    }
}()                                                             

// Advanced: prototype-based scope resolution
function Seven(){
    this.a = 7;
}

// [object].prototype.property 
// loses to [object].property in the scope chain
Seven.prototype.a = -1; 
// won't get reached, because 'a' is set in the constructor above.
Seven.prototype.b = 8; 
// Will get reached, even though 'b' is NOT set in the constructor.

// These will print 1-8
one();
two(2);
three();
four();
alert(new Five().a);
six();
alert(new Seven().a);
alert(new Seven().b);
</code></pre>

<p>尽管有关<strong>原型链</strong>的概念还不是很了解，但是从上面这个例子中，我们应该能很进一步的理解有关JavaScript作用域的知识.当然，从这些代码的角度来<em>研究</em>作用域还是比较<em>浅显</em>的，想进一步了解的同学可以参考一下<a href="http://www.denisdeng.com/?p=908#scope-features">ECMA深入理解</a>.</p>

<h2>闭包 Closure</h2>

<p>在上文中的最后一个例子中有一个是关于解释<strong>闭包</strong>的，我们可以单独拎出来看看：</p>

<pre><code>// Advanced: closure
var six = function(){
    var foo = 6;

    return function(){
        // javascript "closure" means I have access to foo in here, 
        // because it is defined in the function in which I was defined.
        alert(foo);
    }
}()                                                             
</code></pre>

<p>这个例子中的注释已经解释了<em>closure</em>的概念，再来看看<em>JavaScript: the good parts</em>中的说法：</p>

<pre><code>var quo = function (status) {
  return {
    get_status: function() {
      return status;
    }
  };
};

var myQuo = quo("amazed");

document.writeln(myQuo.get_status());
</code></pre>

<p>创建变量<code>myQuo</code>的时候，我们调用了<code>quo</code>，它返回包含<code>get_status</code>方法的一个新对象.该对象的引用包含在<code>myQuo</code>中。即使<code>quo</code>已经返回了，<code>get_status</code>方法仍然可以访问<code>quo</code>对象的<code>status</code>属性.</p>

<blockquote><p>The function has access to the context in which it was created. This is called <em>closure</em>.</p></blockquote>

<p>其实也可以这样理解：当内部函数在定义它的作用域的外部被引用时(比如<code>quo</code>被<code>myQuo</code>引用时),就创建了该内部函数的一个<strong>闭包</strong>(引用可访问该内部函数<code>quo</code>的属性和变量).<br/>
这方面的知识这样梳理下来也是只知道了一个梗概(强烈欢迎指出错误，以及更为简便的理解方式),更多的还是要持续学习啊.</p>

<blockquote><p>以前尝试过在Emacs中用Shell，最近在终端里用Emacs,两者一比,我反而更喜欢后者. 命令：<code>emacs -nw</code> nw应该是no window的意思吧. 不过有很dt的事情,就是快捷键会有冲突, 比如<code>C-y</code>不能粘贴,反而要用终端里的粘贴快捷键<code>C-S-v</code>,又不想改掉快捷键,所以……还是改邪归正吧！</p></blockquote>

<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python中的lambda]]></title>
    <link href="/2013-03-python-lambda-fp/"/>
    <updated>2013-03-20T23:30:00+08:00</updated>
    <id>/python-lambda-fp</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>去年夏天的时候，孤陋寡闻的我第一次见识了Lisp，我的一个同学捧着Galaxy Note在看Practical Common Lisp，于是我略感兴趣然后跟了他的风看了篇Lisp之根源，这是一篇译作，原文是Paul Graham写的。之后同学还饶有兴趣地在我的电脑上安装了Slime + Emacs.</p>

<p>这段经历给我留下的唯一结果是Emacs几乎成为了我最常用的编辑器，而Lisp却没有走进我的生活.</p>

<p>之后，我学了一段时间的Python(A byte of python)，并且在课程作业、日常工作上也经常用到(Machine Learning, File Processing, Lexical Analysis等)，但是遗憾的是我至今还没有尝试过Python的FP.</p>

<p>再后来，就是读七周七语言并逐渐接触到Scala, Erlang, Haskell的日子了.</p>

<p>其实当我看完‘七周七语言’, 对于函数式编程依旧不甚了解, 所知道的也无非是类似“变量不可变”，匿名函数，高阶函数等一些内容;再之后，我在OSChina上翻译了一篇介绍Ruby函数式编程的文章, 那是正好接触了一点函数式编程的思想, 但是翻译的时候还是很生涩的.</p>

<h2>正题</h2>

<p>前几天莫名奇妙的笔了一次Python，很多基础的知识都答不上来，可见自学的成果真是相当差.多的不谈，一言以蔽之--“还不会走路，就想着跑了”.</p>

<p>其中有一题是考的用lambda写一个阶乘函数，果断的悲剧了:(</p>

<pre><code>def factorial(k):
    return reduce((lambda i,j: i*j), range(1, k+1))

factorial(5)
</code></pre>

<p>上面的写法不知道是不是标准答案，但可以确定的是正确答案.</p>

<p>其中reduce函数是用来进行迭代乘积的，而lambda表达式和range函数是作为reduce的参数的.</p>

<pre><code>lambda arg1, arg2,...: expression using args
</code></pre>

<p>这是lambda函数的定义方式，所以说，其实所谓的lambda函数也无非是用来定义匿名函数(Anonymous function)的方式.这在更为'pure'的函数式编程语言如Clojure, Haskell中就如同def在Python中的地位吧？</p>

<p>现在我们可以用Python中的几个函数式编程工具来体验一下这个酷而古老的编程范型：</p>

<pre><code>In [1]: x = lambda n: n+1
In [2]: x(10)
Out[2]: 11
#的确很简单吧
In [3]: filter(lambda n: n%2 == 0, range(1, 10))
Out[3]: [2, 4, 6, 8]
#配合filter函数使用，filter出[1,10)中为偶数的部分
In [4]: map(lambda n: n*3+5, range(1, 10))
Out[4]: [8, 11, 14, 17, 20, 23, 26, 29, 32]
#配合map函数使用，可以对数据进行简单的映射
</code></pre>

<p>用lambda函数在Python中做一些列表解析还是蛮不错的，如果要在lambda表达式中使用if-else语句呢？相必应该很容易想得到：</p>

<pre><code>In [5]: x = lambda x: "Large" if x&gt;2 else "Small"
In [6]: x(3)
Out[6]: 'Large'
#换一种实现方式
In [7]: x = lambda n: x&gt;2 and "Large" or "Small"
#(test and [x]) or [y], test 为真，执行x，否则执行y
In [8]: x(3)
Out[8]: 'Large'
</code></pre>

<p>当然，也可以更像Lisp一点：</p>

<pre><code>In [9]: ((lambda x:(lambda y: x+y))(1))(2)
Out[9]: 3
#虽然只是1+2……
</code></pre>

<p>很多时候是用不到lambda函数的，当然也有很多人对lambda情有独钟，我也在豆瓣某小组中看到过对于这个话题的争论，各执一词，争执不下.</p>

<p>我觉得lambda函数还是很可爱的，可能也与自己本身对于函数式编程也有相当的兴趣有关，当然，关于函数式编程的思想还是不甚了解.</p>

<blockquote><p>说真的，我想学Lisp!</p></blockquote>

<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learn CSS Selectors]]></title>
    <link href="/2013-03-css-selector-note/"/>
    <updated>2013-03-14T00:00:00+08:00</updated>
    <id>/css-selector-note</id>
    <content type="html"><![CDATA[<p>虽说自己蛮喜欢做前端开发的，但是说起来还是有很多知识都是“野生”的，这一说来感觉自己更像是一个“野生的程序员”……嘿，前方出现一个野生的程序员！</p>

<p>玩笑开到这，还是进入正题，所谓“野生”的，也只是想调侃一下自己，毕竟都是自己看书浏览各种教程网站所得——也一直想系统的学习下这方面的知识，所以也就顺便撰文一篇markdown一下，从头开始！</p>

<blockquote><p>In CSS, pattern matching rules determine which style rules apply to elements in the document tree. These patterns, called selectors, may range from simple element names to rich contextual patterns. If all conditions in the pattern are true for a certain element, the selector matches the element.</p></blockquote>

<p>这是<a href="http://www.w3.org/TR/CSS2/selector.html">W3C</a>上的一段话，有点像定义. 简单的翻译一下就是：</p>

<blockquote><p>在CSS中，模式匹配规则决定了文档树中元素应该匹配的样式规则.这些模式，叫做选择器，(选择器的)范围从简单的元素名到复杂的上下文关系模式.如果所有的模式都(匹配)为对应的元素，那么这个选择器就匹配了这个对应的元素.</p></blockquote>

<p>当然，我们可以很容易的在W3C官网上找到<a href="http://www.w3.org/TR/selectors/#selectors">所有的CSS选择器</a>，从level1~3.</p>

<p>从CSS标准进化的角度来看下所有的selector:
(先截取一段本页面的html源代码，以之为示例)</p>

<pre><code>&lt;header&gt;
  &lt;h1&gt;Fantasy's Homepage&lt;/h1&gt;
&lt;/header&gt;
&lt;nav class="mainNav"&gt;
  &lt;span id="homeSpan"&gt;&lt;a href="/"&gt;HOME&lt;/a&gt;&lt;/span&gt;
  &lt;span&gt;&lt;a href="/categories.html"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;/nav&gt;
&lt;article&gt;
  &lt;section&gt;
    &lt;h2&gt;Learn CSS Selectors&lt;/h2&gt;
    &lt;div class="postContent"&gt;
      &lt;p&gt;...&lt;/p&gt;
    &lt;/div&gt;
  &lt;/section&gt;
&lt;/article&gt;  
</code></pre>

<h3>CSS level1：</h3>

<ul>
<li>标签选择器<code>E</code></li>
</ul>


<p>匹配所有使用该标签的元素:</p>

<pre><code>h2 { ... }
</code></pre>

<ul>
<li>class选择器<code>.class</code></li>
</ul>


<p>匹配所有类元素中包含该指定class的元素：</p>

<pre><code>.mainNav { ... }
nav.mainNav { .. }  
</code></pre>

<ul>
<li>id选择器<code>#id</code></li>
</ul>


<p>匹配所有id属性为该指定id的元素:</p>

<pre><code>#homeSpan { ... }
span#homeSPan { ... }
</code></pre>

<ul>
<li>后代元素选择器<code>E F</code></li>
</ul>


<p>匹配所有E元素的后代元素F：</p>

<pre><code>span a { ... }
</code></pre>

<ul>
<li>链接伪类<code>E:link</code> <code>E:visited</code></li>
</ul>


<p>匹配所有(未)被点击的链接：</p>

<pre><code>a:link { ... }  
a:visited { ... }
</code></pre>

<ul>
<li>用户操作伪类<code>E:active</code> <code>E:hover</code> <code>E:focus</code></li>
</ul>


<p>匹配一些用户操作的选择：</p>

<pre><code>/*按下链接，但未释放*/  
a:active { ... }  
/*鼠标移动到链接上*/  
a:hover { ... }  
/*元素获得焦点*/ 
a:focus { ... }  
/*这里的问题是如何判断链接获得焦点呢？所以更多的，:focus伪类用于input标签等*/
</code></pre>

<ul>
<li>first伪元素<code>E::first-line</code> <code>E::first-letter</code></li>
</ul>


<p>匹配E元素下的第一行(字母)</p>

<pre><code>p::first-line {
  text-transform: uppercase;
}  
/*p元素下首行文字被transform为大写*/  
p::first-letter {
text-transform: uppercase;
}  
/*p元素下的第一个字母变为大写*/
</code></pre>

<h3>CSS level 2</h3>

<ul>
<li><p>通用元素选择器<code>*</code> （匹配所有元素）<br/>
<code>* { ... }</code></p></li>
<li><p>属性选择器<code>E[foo]</code> <code>E[foo="bar"]</code> <code>E[foo~="bar"]</code> <code>E[foo|="en"]</code></p></li>
</ul>


<p>根据不同选择条件进行匹配：</p>

<pre><code>a[href] { ... }  
/*匹配带有href属性的a标签*/  
a[href="/home.html"] { ... }  
/*匹配href属性为"/home.html"的a标签*/ 
a[rel~="copyright"] { ... }  
/*若a元素下的rel属性为"copyright copyleft copymiddle"，这样就能匹配到该元素，而不用使用a[rel="copyright copyleft copymiddle"]*/
a[hreflang|="en"] { ... }  
/*匹配所有a标签下hreflang属性中带有连字符的并以"en"开始的元素*/  
</code></pre>

<ul>
<li>结构化伪类<code>E:first-child</code></li>
</ul>


<p>匹配所有E元素，条件是E元素为其父元素的第一个子元素</p>

<pre><code>p:first-child { ... }
</code></pre>

<ul>
<li>语言伪类<code>E:lang(fr)</code></li>
</ul>


<p>匹配所有语言类型为'fr'的元素</p>

<pre><code>&lt;body lang=fr&gt;
  &lt;p&gt;Je suis français.&lt;/p&gt;
&lt;/body&gt;

/*如果匹配条件为[lang|=fr]，那么只会匹配到body元素;
而如果是:lang(fr)那么会匹配到body和p元素，因为它们都是用法语的内容.*/
</code></pre>

<ul>
<li><code>E::before</code> <code>E::after</code> 伪元素</li>
</ul>


<p>在指定元素前生成指定内容</p>

<pre><code>/*在E元素前生成内容*/
p::before { content:"note:" }
</code></pre>

<ul>
<li>子元素选择器<code>E &gt; F</code></li>
</ul>


<p>匹配所有E元素下的F元素</p>

<pre><code>nav &gt; span { ... }
</code></pre>

<ul>
<li>毗邻元素选择器<code>E + F</code></li>
</ul>


<p>匹配紧跟着E元素的同级F元素</p>

<pre><code>header + nav { ... }
</code></pre>

<h3>CSS level 3</h3>

<ul>
<li>属性选择器<code>E[foo^="bar"]</code> <code>E[foo$="bar"]</code> <code>E[foo*="bar"]</code></li>
</ul>


<p>根据不同条件进行匹配</p>

<pre><code>E[foo^="bar"]  
/*E标签中foo属性的值以"bar"开始的元素*/   
E[foo$="bar"]  
/*与上面一个正好相反，E标签中foo属性的值以"bar"结尾的元素*/  
E[foo*="bar"]  
/*E标签中foo属性的值含有"bar"的元素*/  
</code></pre>

<ul>
<li>结构化伪类<code>E:root</code> <code>E:nth-child(n)</code> <code>E:nth-last-child(n)</code> <code>E:nth-of-type(n)</code> <code>E:nth-last-of-type(n)</code></li>
</ul>


<p>具体解释如下</p>

<pre><code>E:root  
/*文档的root元素，在HTML4中，永远是html标签(W3C这样说的，实际对于上HTML文件都是html)*/
E:nth-child(n)  
/*E的父亲元素的第n个子元素*/  
E:nth-child(odd)  
/*就可以表示E的父亲元素下奇数号的元素*/
E:nth-last-child(n)  
/*与E:nth-child相反，从E的父亲元素下最后一个子元素向前计数*/
E:nth-of-type(n)  
/*与E:nth-child(n)相似，但是只能匹配与E为同类(siblings)的元素标签*/
E:nth-last-of-type(n)  
/*与E:nth-of-type相反*/
</code></pre>

<ul>
<li>结构化伪类<code>E:last-child</code> <code>E:first-of-type</code> <code>E:last-of-type</code> <code>E:only-child</code> <code>E:only-of-type</code> <code>E:empty</code></li>
</ul>


<p>具体解释如下</p>

<pre><code>E:last-child  
/*等同于E:nth-last-child(1),匹配所有以E为最后元素的父元素下的子元素E*/
ol &gt; li:last-child  
/*匹配ol中的最后一个li元素*/
E:first-of-type  
/*等同于E:nth-of-type(1)*/
E:last-of-type  
/*等同于E:nth-last-of-type(1)*/
E:only-child  
/*匹配一个有父亲元素但是该父亲元素没有其他子元素的元素*/
E:only-of-type  
/*匹配一个有父亲元素但是该父亲元素没有相同扩展元素名的子元素的元素*/
E:empty  
/*匹配一个不包含任何子元素的节点（包含文本节点）*/
</code></pre>

<ul>
<li>目标伪类 <code>E:target</code></li>
</ul>


<p>有些URI指向的是同一份资源中的一部分，也就是常见的带有#标记的链接</p>

<pre><code>html:target { ... }
/*为html文档中所有target元素添加样式*/
</code></pre>

<ul>
<li>UI元素状态伪类 <code>E:enabled</code> <code>E:disabled</code> <code>E:checked</code></li>
</ul>


<p>匹配所有状态为<code>enabled</code> <code>disabled</code>或者<code>checked</code>的元素，特地查看了下, enable/disable想必大家都了解，
所谓checked就是指一些<code>radio-button</code>或<code>checkbox</code>中的状态</p>

<ul>
<li>否定伪类 <code>E:not(s)</code></li>
</ul>


<p>匹配所有符合否定条件的元素</p>

<pre><code>button:not([DISABLED])  
/*匹配所有可以点击的按钮*/
html:not(nav) { ... }  
/*匹配所有除nav元素以外的元素*/
</code></pre>

<ul>
<li>同级元素选择器 <code>E ~ F</code></li>
</ul>


<p>匹配所有在E之后的并与E同级的元素F</p>

<pre><code> h2 ~ p { ... }
</code></pre>

<h3>参考资料</h3>

<ul>
<li><a href="http://www.w3.org">w3.org</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html">阮一峰的网络日志</a>:这篇文章发布于2009年，
但是内容已经很详尽，不过感觉缺少稍微详细点的描述以及更为生动的例子.</li>
</ul>


<blockquote><p>本文整理了很久，真的只有整理了，才知道自己的知识有多凌乱不堪。</p></blockquote>

<p>--EOF--</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sign.]]></title>
    <link href="/2013-03-sign/"/>
    <updated>2013-03-11T00:00:00+08:00</updated>
    <id>/sign</id>
    <content type="html"><![CDATA[<p>Having used <a href="http://en.wikipedia.org/wiki/OpenSUSE">openSUSE</a> 12.2 for nearly 1 week and being suffered from crash, I downloaded <a href="http://en.wikipedia.org/wiki/Linux_mint">Linux Mint</a> and then installed it immediately.</p>

<p>This reason is not convincing, however, I tried my best to rescue it and failed(nvidia driver may caused it).</p>

<p>Since I started to use GNU/Linux, a door of Open Source opened to me and the spirit of Freedom hit me. I am curious to try different Linux distributions and happy to find things interesting in them. YinWang did influenced me most(though he posted a <a href="http://blog.sina.com.cn/s/blog_5d90e82f0101ip7f.html">blog</a> in a opposite method several day ago).</p>

<p>I'm not an expert in Operating Systems, but I do have rich experience in using them(especially GNU/Linux and M$ Windows).</p>

<p>Here I don't want to talk anything about the advantages and disadvantages about them. GNU/Linux makes me comfortable except the X-windows( and it must be the main reason people hate it and not eager ot use it). Not long ago, I heared that Ubuntu is developing its own desk environment instead of X-windows( T/F? ). That is amazing if it is true.</p>

<p>It is really a mess in my mind when I recall the memory of using different distributions. Let me stop it.</p>

<p>After all, Linux Mint is pretty good for me to use, it is simple and user-friendly. The KDE of Mint is the best one I ever used. One more thing, it is compatible with Ubuntu applications. And I didn't find any problems using it until now.</p>

<p>I will use Linux Mint for the rest time of my college life.</p>

<p><em>but you know, once Linuxer have money, they will buy a Mac Book : )</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS布局原理入门]]></title>
    <link href="/2013-03-zz-css-fundemental/"/>
    <updated>2013-03-10T00:07:00+08:00</updated>
    <id>/zz-css-fundemental</id>
    <content type="html"><![CDATA[<p>本文出自@寒冬winter的<a href="http://photo.weibo.com/1196343093/wbphotos/large/photo_id/3554004161919635?refer=weibofeedv5">微博</a></p>

<p>由于原照片过于……卖萌(亮瞎)，所以整理一个正常一点的文章来记录并分享一下。</p>

<p>首先，我们来了解一下神马叫做盒(box)</p>

<pre><code>&lt;div&gt;
  some text
  &lt;p&gt;some text
&lt;/div&gt;
</code></pre>

<p>这是源代码，里面的<code>&lt;div&gt;</code>和<code>&lt;p&gt;</code>叫做"标签(tag)".</p>

<pre><code>div
 |__ [text]
 |__ p
     |__ [text]
</code></pre>

<p>当浏览器把他们读入内存的时候，会形成"节点(node)"</p>

<pre><code> -------------
|  _________  |
| |some text| |
|  ---------  |
| |some text| |
|  ---------  |
 ------------
</code></pre>

<p>浏览器再把他们显示到屏幕上，让用户可以看到的就是所谓的"盒(box)"了</p>

<p>盒不仅仅是简单的一个矩形，它还包含很多要素：留白(margin)、边框(border)、边距(padding)、内容(content).</p>

<p>这些就是所谓的"盒模型"啦.</p>

<p><img src="../media/img/css_boxmodel.png" alt="Box Model" /></p>

<p>跟节点(node)一样，盒形成了一个树形结构，通常这些结构被称作"渲染树(render tree)"</p>

<p>然而只有盒子(box)是木有用的，浏览器还必须知道把这个盒子摆放在什么位置.</p>

<p>决定盒子位置和大小的，就是盒子所在的"格式化上下文(formatting context)"</p>

<p>基本的个是化上下文有两种：块格式化上下文(block formatting context)和行内格式化上下文(inline formatting context)</p>

<p>block formatting context就是传说中的BFC啦. 你一定听过这个很高端的名词吧.
<img src="../media/img/bfc.png" alt="BFC" /></p>

<p>简单来说，BFC和IFC的区别是，BFC里面的元素是沿着竖直方向排列的，而IFC里的元素则是水平方向.
(事实上这还跟语言文字本地化设置有关，咱本文中暂且不表)</p>

<p>页面的最外层，也就是浏览器的网页绘制区域，是一个BFC.
<img src="../media/img/bfcifc.png" alt="bfcifc" /></p>

<p>盒子会根据它所对应的节点的子节点display性质来决定自己是BFC还是IFC.</p>

<p>比如，下面这个div会生成IFC</p>

<pre><code>&lt;div&gt;
&lt;span&gt;aaa&lt;/span&gt;
&lt;a&gt;good&lt;/a&gt;
&lt;/div&gt;
</code></pre>

<p>而若是至少有一个子节点的display是block级别的，那么就一定要生成BFC啦^^.</p>

<pre><code>&lt;div&gt;
&lt;span&gt;aaa&lt;/span&gt;
&lt;a&gt;good&lt;/a&gt;
&lt;p&gt;hahaha
&lt;/div&gt;
</code></pre>

<p>然而问题出来啦，inline级别的元素怎么可以放进入BFC呢？
<img src="../media/img/question.png" alt="question" /></p>

<p>答案是，浏览器会生成一个"匿名盒(anonymous box)"来容纳这些inline元素
<img src="../media/img/anonymous.png" alt="anonymous" /></p>

<p>你一定注意到了我提到的一个概念：inline级别，事实上差不多每一个盒子都有inline和block两个级别，看看这些display的值吧：</p>

<pre><code>block inline-block
table inline-table
flex  inline-flex
grid  inline-grid
</code></pre>

<p>值得注意的是，并非所有display为block的元素，都会在它的box里面创建BFC.</p>

<pre><code>&lt;div&gt;
  &lt;div id="小透明" style="overflow:visible"&gt;
    &lt;p&gt;hahahaha
  &lt;/div&gt;
  &lt;p&gt;hohohoho
&lt;/div&gt;
</code></pre>

<p>比如这里的小透明，因为它的overflow是visible，所以它的子节点p的box是直接放进外部BFC里面的.</p>

<p>因为BFC会影响到float、边距折叠(margin-collapse)等等特性，所以识别出小透明们就十分重要了.</p>

<p>除了BFC和IFC，还有一些其它的格式化上下文：比如flex和inline-flex元素会在其盒内创建弹性化上下文(flex formatting context, FFC)，而table和grid也会创建不同的格式化上下文（虽然标准中木有使用这个术语）.</p>

<p>肯德基老爷爷创建的是KFC，Kentucky Fried Chiken，请不要搞混哦.</p>

<p>总结一下，浏览器正常流中，会有多种不同的布局方式，其中最为主要的布局方式就是基本布局，它使用两种格式化上下文BFC和FIC来完成布局。</p>

<p>在基本布局中，有些盒子可以在其内部生成不同的格式化上下文，有些则根本不生成格式化上下文.然而不论如何，基本布局中的盒子要么是inlnie-level的，要么是block-level的.</p>

<p>值得一提的是，全部页面上的盒子分为正常流(normal flow)、浮动(floats)、绝对定位(absolute positioned)三种，而本文所讲到的仅仅是正常中的盒子表现.</p>

<pre><code>box(盒)

* floats(浮动)
* absolute positioned(绝对定位)
* normal flow(正常流)
  * inline-level(行内级)
  * block-level(块级)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu Touch Preview 尝鲜]]></title>
    <link href="/2013-02-ubuntu-touch-preview/"/>
    <updated>2013-02-23T19:55:00+08:00</updated>
    <id>/ubuntu-touch-preview</id>
    <content type="html"><![CDATA[<p>前段时间Canonical发布了Ubuntu Touch Preview, 正好本人有Nexus 7可以一试(也不怕数据丢失).</p>

<h2>安装</h2>

<p>安装的过程很简单,<a href="https://wiki.ubuntu.com/Touch/Install?action=show&amp;redirect=TouchInstallProcess">wiki.ubuntu.com</a>.</p>

<p>关于Android设备在Linux上的挂载问题, 可以参考<a href="http://archboy.org/2012/09/17/linux-connect-google-nexus-7-file-system-adb-development/">这里</a></p>

<p>只是不知道是家里的网速慢还是其他的原因,下载这一过程花了很多时间.</p>

<h2>体验</h2>

<p>说实在的, 一段时间体验下来, 应该是因为是预览版(preview)所以很多功能都只是"摆设". 下面结合一下图片来讲解一下自己的体验.</p>

<p>先来看这个系统的Home Screen:</p>

<p><img src="../media/img/home.jpg" width="225" height="400"></img></p>

<p>这个界面还是蛮漂亮的, 色彩也很有Ubuntu的特点, 不过那圈圈里的14 tweets received是硬编码进去的...略搓</p>

<p>App界面:</p>

<p><img src="../media/img/app.jpg" width="225" height="400"></img></p>

<p>遗憾的是Available for download里的app还不能下载.</p>

<p>侧边栏选择App：</p>

<p><img src="../media/img/homee.jpg" width="225" height="400"></img></p>

<p>这个功能很好，而且与GNOME的Desktop版很像.</p>

<p>Game:</p>

<p><img src="../media/img/game.jpg" width="400" height="225"></img></p>

<p>系统原有的一个游戏, Ski Safari, 只是不能玩……这点有点坑爹> &lt;</p>

<p>Gallery:</p>

<p><img src="../media/img/gallery.jpg" width="225" height="400"></img></p>

<p>浏览器:</p>

<p><img src="../media/img/browser.jpg" width="225" height="400"></img></p>

<p>Gmail：</p>

<p><img src="../media/img/gmail.jpg" width="225" height="400"></img></p>

<p>键盘：</p>

<p><img src="../media/img/keyboard.jpg" width="400" height="225"></img></p>

<p>不得不说这个键盘亦是一个败笔……太小而两边的空白太多(难道是因为是平板的原因?!)</p>

<p>发现的一个Bug:</p>

<p><img src="../media/img/bug.jpg" width="225" height="400"></img></p>

<p>在切换的时候, 发现键盘不会自动移下去而要手动拨下去.</p>

<h2>感受</h2>

<ul>
<li>使用下来感觉整个系统还是蛮流畅的, 当然还是有时候会有点顿卡的.</li>
<li>应用不多, 不过对于预览版而言还是不算缺陷的, wp作为一个产品不还是应用匮乏咩 : )</li>
<li>对于手势还是不了解,如果熟悉的话应该操作会更舒服点.</li>
<li>确实有很多bug, 不过还是可以原谅的.</li>
<li>体验还不错, 其实很期待作为一个真正的系统而非预览版的时候能达到什么样的程度.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语言的魅力]]></title>
    <link href="/2013-02-seven-languages/"/>
    <updated>2013-02-20T16:07:00+08:00</updated>
    <id>/seven-languages</id>
    <content type="html"><![CDATA[<h4>写在七周七语言之后</h4>

<p>匆匆合上此书，不得不承认自己最学习一门新的语言有着很高的兴趣，这一点特别展现在结束一门语言的学习任务进入下一门的时候——兴奋与期待。</p>

<p>每一门语言都是由简至繁, 这一点从附加的练习上可见一般.</p>

<p>这本书不是一本教会你如何写各种语言Hello World的书, 当然也不是一本教你从入门到精通的书; 而是<a href="http://en.wikipedia.org/wiki/Paradigm">Paradigm</a>.</p>

<p>这期间, 接触到了七种不同语言的不同特性, Ruby, Io, Prolog...印象中名称这些不再是曾经听闻过的"名字", 而是亲身体验过的可以用来"实践"的Programming languages. 很多特性是让人惊讶的, 如何去使用之解决一些问题则是作者教会我们的内容.</p>

<p>此书带来的最大的效果不是让我学会了Clojure或者Haskell, 当然也没有完全帮助我理解了函数式编程的概念, 事实上这也是不可能的. 在如此短的时间之内要学会一门语言, 哪怕是熟悉这门语言的最常用的语法函数, 没有那么简单. 虽然说大多数语言的语法之间的差别不是很大, 特别是借鉴了C语言的语言, 对于我这种在科班之中学习过C++的人而言, 更是熟悉不过了. 但是具体到细节中却又有不同之处, 这可以从书中细细体味.</p>

<p>这本书的模式相信不仅仅是对于语言的不同范式而适用的, 也可以借鉴到其他的书籍写作中.</p>

<p>书是读完了, 为我打开了一扇大门, 前方的旅途就要自己探索了.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[可贵的经历]]></title>
    <link href="/2013-01-excellent-experience/"/>
    <updated>2013-01-29T13:55:00+08:00</updated>
    <id>/excellent-experience</id>
    <content type="html"><![CDATA[<ul>
<li>评"打造Facebook"</li>
</ul>


<p>如果我是一个创业团队的一员，想必能从其中获得很多启发。比如招聘、比如开发流程、比如“工具文化”等等，这些细节可以从这本书中慢慢品味了解。</p>

<p>作者是第二位华裔员工，加入的也比较早，所以对Facebook这么几年来的发展有很深刻的了解，所以从这本书中获得的经验也是可谓“第一手”的。</p>

<p>有一句话印象很深刻，“you cannot claim you are a Facebook engineer if you have not brought the site down!“，感觉这是一种很鼓舞人心的话。整本书不过200多页，但覆盖的面的确挺广，创业开发文化投资等等。</p>

<p>不过还是要吐槽一下书的质量（京东买的，应该是正版吧），之前没买过“印刷工业出版社”的书，感觉纸张略厚，但是又不是那种很细腻的纸，所以翻起来感觉不是很爽，所以给了四星；不过排版方面还行。如果@nonoidea 以后出书的话还是换个出版社吧 > &lt;</p>

<p>ps: 第二作者祝文让是谁……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ignore the title]]></title>
    <link href="/2013-01-ignore-title/"/>
    <updated>2013-01-19T23:47:00+08:00</updated>
    <id>/ignore-title</id>
    <content type="html"><![CDATA[<h4>评  『Delivering Happiness (三双鞋)』</h4>

<p>   回家的动车上看了大半本，后来两天陆陆续续的读完了整本书。</p>

<p>   起初还想吐槽下对于“三双鞋”这个书名的“看法”，后来看到书评里有本书的“小编”的解释，其实还是不太赞同，建议在后续再版的时候还是取一个“平实”的书名为好。</p>

<p>   看完留在脑海里的印象全是谢家华那出众的才华和胆识，当然，是在他长大、创业的旅途中显现出来的。</p>

<p>   一个学习丝毫不认真、少年时期就一心想着赚钱然后迸出各种点子的男生就”稀里糊涂“地进了哈佛，而在进哈佛之后第一件事情居然是窝在寝室里看电视（没有记错的话），不得不说他是一个奇才。由于名校毕业，又轻松的进了这年头高高在上的Oracle……</p>

<p>   然后，然后就是更为“辉煌”的创业生涯了－－网页设计、链接交换、美捷步。</p>

<p>   当然，文章中大篇幅的还是讲的谢家华在美捷步的经历。如何扩展销量、起死回生等等。其后还通过本书给我这种之前没有听说过美捷步文化的人一一细讲了文化内涵。</p>

<p>   能坚持、有胆识、敢拼老本、敢于创新，谢家华以后会不会给商业界带来惊喜？！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文副'揭秘']]></title>
    <link href="/2013-01-wen-fu-jie-mi/"/>
    <updated>2013-01-10T22:16:00+08:00</updated>
    <id>/wen-fu-jie-mi</id>
    <content type="html"><![CDATA[<h4>『HTML5 up and running (HTML5揭秘)』</h4>

<p>　  这本书是2010年出版的，而我却在HTML definition completed之后才读这本书。
　<br/>
　  其实评价“还行”有点不厚道，但是选择“推荐”又感觉不恰当，最终还是选择了“还行”。
　<br/>
　  一开始看这本书是下载的英文电子书，无耻的促进了盗版 :(   后来发现室友有这本实体书，就借来一阅。
　<br/>
　  题取“揭秘“，文副其实。
　<br/>
　  虽然很多标签、特性都已经了解了，但是还是从头到尾看完了本书。感觉还是介绍为主，不会教你如何去实现一个HTML5游戏或者应用，所以更像一本“科普”性质的书。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Boring Summary of 2012]]></title>
    <link href="/2012-12-a-boring-summary/"/>
    <updated>2012-12-31T11:01:00+08:00</updated>
    <id>/a-boring-summary</id>
    <content type="html"><![CDATA[<p>As 2012 is already in the end, it is really a tremendous fortune for us because 2012 is not the end of the world.</p>

<p>Looking back on my 2012, just as the old saying goes, "Life is short and time is swift.", 2012 is short and time is flash!</p>

<p>Now, you can read any part of me if you are interested in. (Pls don't use sarcasm as comments)</p>

<h2>Reading</h2>

<p>The number of books I read this year is more than it in the last two years(20 or more), which makes me feel shame for what I was doing during that time.</p>

<p>However, it is still not enough, as I saw many people in Turing community showing their reading list of 2012. It is also an inspire for you to have a look about this topic.</p>

<p>Here comes up an inspiring sentence,"Power is that the ones who are 10 times better than you works are still working harder than you."</p>

<p>Tragically, through the reading period, I did not have learnt a lot from books.</p>

<ul>
<li>Novels like "1988, I want to talk with the world" and "The Cathcer in the Rye" can only make me more disappointed about the social environment, which can reflect many phenomenons in China and also in other countries.</li>
</ul>


<p>What is more odd for me is that I have already lost confidence of living in such a hypocritical society: not only the party and the government officials, but also the average in the super markets and streets: the goods they threw away, the rude way they speak and the crowd crowding into buses, I began considering about the root of these uncivil behaviors. It is really OT, oh my goddess! Let me stop thinking about it.</p>

<ul>
<li><p>Books pertaining to Traveling and something related to it do waste money and time. I ever bought several ones and spent time envying that kind of life. Believe me, that is really wasting time and you can get nothing but envy.</p></li>
<li><p>Some books do take effect, such as "Dark Time" written by Wei.P.Liu. Reading books tagged psychology can make a true influence, just as what the author said in the book, "Everybody should have a look at books about psychology". As a result, I kept a to-do list for nearly a term and even try to plan my time in detail incredibly.</p></li>
<li><p>My attitude changed: I started having interest in Reading. As a result, I bought a tablet called Nexus 7 which is produced by my favorite company--Google. It is cute and only 7-inch.</p></li>
</ul>


<h2>Development</h2>

<p>I am always curious about new Technologies, which is really a disadvantage in my own eyes.</p>

<h4>Languages</h4>

<p>I was in the corner of the programming world and knew less about different languages, though I knew lots of names like ada, brain fuck and so on.
It's not suitable for me to discuss about the advantages and disadvantages about any language, because I am an expert of nothing.</p>

<p>This year, 2012, I have been touch with many different languages. However, this experience is really a chaos and make me stay being an expert of nothing.</p>

<p>Early in the past two years, I even regarded 'dynamic' the same as 'weakly typed', that is really ridiculous as far as I can see. And what make me more confused is that even some student who major in CS or SE do not know what is compiled language and what is interpreted language.</p>

<p>After the training this summer, I began to show large interest in front-end development rather than what rAy's favorite --JavaEE. I don't hate Java, nor do I like it. HTML is so simple and it is not known as a programming language, I agree with this point. But CSS is complicated than I expected, later I knew LESS, Stylus and other kinds of technologies which make CSS more like a language. Bootstrap and Metro UI CSS are what I used most until now, what really amazed me is O'reilly even published a book about using Bootstrap.</p>

<p>I read a JavaScript book in Head First series which is good for green-hand like me. However, with little chances to use it, I am still not able to develop a complex application which JavaScript is the major language. Libraries like jQuery, YUI, KISSY and Arale are what I want to learn to use in the coming new year. Later I knew Node.js, this makes me know more about JavaScript(if you never heard about it, Google and it may shock you), and I've ever tried to use it but not deeply.</p>

<p>Not long ago, I used an afternoon to read a book about Ruby in the library --Learning Ruby. That is a period I have began to learn Python. They are really similar with each other, while Ruby seems more flexible. I prefer Python, because it is more rigorous and it can do more than Ruby(maybe RoR is very popular nowadays in web development). I started to learn Python several months ago after I read a book called A Byte Of Python which is quite simple and brief. Later I started to use Django to develop web application, that is really easy for developers to quick start and deploy. During that time, the skill of building web pages improved. In daily life, I may use Python as a scripting language like shell scripting. They are both efficient, but Python seems more friendly to me. Learning Python is more likely a reference book on my bookshelf like Linux Shell Scripting Cookbook.</p>

<p>Some weeks ago, I began to read a book named Seven languages in seven weeks. I posted blogs to show my answers to the questions in that book, however my classmates seemed unhappy to see these blogs. I think I will not stop and finish it later. Blog is the highest level of self-expression, if anyone don't want to scan them, move your gaze down to others. I just want to record my journey and keep learning new things.</p>

<h4>Editors/IDE</h4>

<p>The debate between VIM and Emacs never stop just like the debate between Windows and Linux. So it is useless to convince others to use the same editor with you. I chose Emacs.</p>

<p>The first reason is Emacs is written by Richard Stallman, OK, this reason may be ridiculous; Second reason is I don't like the way VIM works --press ESC to change working condition , that is inefficient for me. Also, Emacs is written in lisp and that is the language standing on the top of programming, adoring made the choice; Another reason, lots of classmates chose VIM as their editor, I just want to be different and try a new way.</p>

<p>Sublime Text 2 is a outstanding editor. It is fast enough and more user-friendly, also, it supports lots of plugins for most languages. But I am not in favor of such a modern one, maybe I am out of time.</p>

<p>People call Emacs a editor, but those who are its super fan call it an OS rather than an IDE or even an editor. I'm trying to make it more likely an IDE to make me do things more efficient, to do this, I printed the GNU Emacs Reference Card and put it near my hand in order to learn to use it quicker. Maybe years later, it will be my mini OS in my Linux.</p>

<p>This year, Netbeans became my most used IDE as I have to write JSP files for our teams' projects. Netbeans is an excellent IDE for Java programming and front-end development. However, many other IDEs can do such kinds of works, too. Its interface is cleaner and simpler.</p>

<h2>Communities</h2>

<h4>Mailing List</h4>

<p>Mailing list is a little like forum. But they look totally different some times.</p>

<p>I subscribed some mailing list and received E-Mails from them everyday. I was excited to post my question in NJLUG first time. After several weeks, I created our team's mailing list. But it seemed that only predator.rAy was interested in communicating with E-Mails. That is a pity.</p>

<p>Now, I will check my GMail everyday(nearly all the time if I am online) and have a look at what people in groups are doing all day. CPyUG is such a big one that many topics are posted everyday, and I can see hot discusses everyday. NJLUG, HZLUG and SHLUG are all mailing list about Linux, but they are not as lively as CPyUG.</p>

<p>Mailing list is such a traditional but modern way, how I wish my mates can work together and use it with me.</p>

<h4>Q&amp;A sites</h4>

<p>We Chinese always copy ideas from foreigners'. Zhihu is the Chinese version of Quora, Segment Fault is the Chinese version of Stack Overflow.</p>

<p>In this year, I have tried to be a member of all this sites for a while or a long time. In Zhihu, if some famous people answer questions, they can always get voted even the answers are boring enough. Well, as what I experienced in Zhihu these weeks, I asked 4 questions which were all meanful but only 3 or less ones answered me. It is such a bad feeling that no one answered you in a Q&amp;A community. Then I turned to the original version of these kinds of sites --Quora. More comfortable, more honest and more equality. Stack Overflow is a new-born site in China ant the number of users in not large, but the ones on it are hot-hearted like the people in the QQ group --SF developers.</p>

<h4>Git/Github</h4>

<p>I joined Github in the early April this year. I even didn't know what Git is and the similar tools like  SVN or CVS though they are a little bit old-fashioned.</p>

<p>This summer, we use SVN to synchronize our codes on Google Code. SVN is quite simple and efficient. But Git has a strong point --commit changes to local server, that means we can commit our code any time even we are offline. Surly there exist lots of other advantages. Selfishly, Git is invented by Linus(I'm his big fan). And now, I am familiar with using Git and widen my knowledge about it.</p>

<p>I am still new to Github though it is 8 months after I registered. I am building my Git-page on it, putting my practice on it, doing projects with my mates on it and visiting famous projects on it. What else can I do? Maybe later I can contribute to some open source projects, that may be really cool!</p>

<h2>Addition</h2>

<ul>
<li>GFW</li>
</ul>


<p>Several days ago, I saw an issue which is opened in a project called mongol on Github. Here is the address of that project.</p>

<p>The reason why I support 'conanca' is very simple, GFW do block many sites and that is really inconvenient for us to use other 'cross-GFW' ways except modifying the hosts file. Buying a VPN account seems a good way, but that will surly cost money and we don't have any income in the college.
If we can save a website like Github from being blocked by GFW, why not?</p>

<p>Here I remember another topic of breaking GFW, some software like Free Gate are really evil! Though I am not a follower of CCP, but most of expressions are too disharmony. What do I mean? You can download a Free Gate and have a try.</p>

<p>Last two years, I am eager to break the GFW and excited about visiting Facebook, Twitter and Youtube. Yet not this year. Oppressing for years, we have little friends and nothing can we share there. The purpose of getting out is watching videos on Youtube, visiting blogs on Blogspot and download some files from blocked sites. It is really a luck for everyone that Google is not totally blocked in China except the time of NPC.</p>

<ul>
<li>Social Networks</li>
</ul>


<p>I tried to write an article about the future of SNS, but failed. As I considered, I didn't get rich understanding about the principles and the current situation. So I gave up.</p>

<p>I used to visit Renren often, but then turned into Weibo this year. They are really different social networks.</p>

<p>I preferred to Renren because I can see what my classmates(both high school and university, or even primary school) are doing recently. Are they happy these days or in sadness? What happen in their daily life? And what they are discussing about? That is quite an huge attraction of this kind of web sites. But after a long time, may be a year or two, it is becoming more and more obvious that the someone are over self-expressed while the others are not. Those who are too addicted to Renren always post some boring words or images, as you know, self-snapshots or something like that. Everything should be limited, you are taking photos all day and uploading them to Renren, I can not tolerate and have to block you.</p>

<p>But Weibo is different. Although I have less people known on it, I can follow many coders at work tagged Taobao, Python, JS or maybe Linux. What they push to the Internet is more valuable. And I can know many things earlier than ever before, I can know what is happening in the society but not limited to several campuses, I can get rid of those who like self-snapshot though I can block them in Renren. Weibo is a more efficient way to transport knowledge and technologies and it is also a higher level for self-expression.</p>

<ul>
<li>this.About</li>
</ul>


<p>With my poor English, welcome to point out my grammar bugs and I will fix them as soon as possible.
The reason why I wrote this article in English is that may make less people interested in this passage. If you are patient enough to read the whole sentences, you must find it is such a mess.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[这到底『他妈的』是一本什么书]]></title>
    <link href="/2012-12-what-a-fucking-book/"/>
    <updated>2012-12-04T12:00:00+08:00</updated>
    <id>/what-a-fucking-book</id>
    <content type="html"><![CDATA[<p>(评『麦田里的守望者』)</p>

<p>这是一本从一开始就满是脏话的小说，充斥着“他妈的”之类的话语。</p>

<p>其实这是很让人反感的一点，至少我是那么觉得的，所以在起初开始阅读这本书的时候的确有点怀疑——这到底“他妈的”是一本什么样的书？</p>

<p>不过让我觉得奇怪的是，出了令人反感的脏话，这本小说不同于以前看过的很多所谓的名著：阅读本书的时候不会觉得有什么“阻碍”。</p>

<p>这里的阻碍即阅读的时候出现的不快——对于个别生涩词藻的难以理解、对于上下文关系的难以在思维上进行愉快的连接……</p>

<p>所以从这一点来看，我又不禁觉得这是一本好书。</p>

<p>　　
阅读期间，一直想知道霍尔顿接下来会做什么事——难道我真的已经被这个被学校开除的男生的“吐槽”社会之旅给吸引了？！</p>

<p>我想，的确是的。</p>

<p>　
各种丑陋的学校、社会上人物的姿态在霍尔顿的瞳孔里被放大，这个愤世嫉俗的男孩的脑海里恐怕都是“伪君子”、“假模假式”之类词语。每个人的任何缺点都逃不出他的眼睛。</p>

<p>霍尔顿简直可以把自己称作“人性的侦探”。</p>

<p>　　
其实可以看出他看过很多文学的著作，包括诗歌、剧本、小说。</p>

<p>可是在潘西那个“遭透了的”学校里，却被几乎压抑成人格分裂，对，就是人格分裂。</p>

<p>当霍尔顿偷偷回到家里，见到妹妹之后，给人一种将压抑许久的、无处发泄的愤怒，都宣泄了出来，同时又给人一种——人格分裂的感觉。</p>

<p>　　
当他说出以后想当一个“麦田里的守望者”的时候，我又几乎动容了。</p>

<p>想象一个被学校、同学、社会上各种“假模假式”的人腐蚀很久的人，突然描绘出那么一副宁静、祥和、有爱心的场景，真的，感觉就像三井一头长发、跪在地上跟安西教练说“教练，我想打球”的样子。</p>

<p>　　
不过，有点出乎我意料的是：最后的结局。</p>

<p>我还真的天真的以为霍尔顿会搭车去西部，然后周围的人都不认识他，过上新的生活之类的，或者还会有一块麦田、然后做一个麦田里的守望者。</p>

<p>但是……他居然回去了！这也算是欧亨利式的结尾是么 ORZ</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[It is just for fun]]></title>
    <link href="/2012-12-it-just-for-fun/"/>
    <updated>2012-12-02T11:16:00+08:00</updated>
    <id>/it-just-for-fun</id>
    <content type="html"><![CDATA[<h4>评《Just for fun》</h4>

<p>   说起Linux可能无人不知，说起Linus可能也万人敬仰，而这本Linus Torvalds的自传可能就相对默默无闻多了，全书不过100多页，却展现了Linus从小时候在外公膝盖上开始敲击键盘打字、在自己的小房间里“偶尔朝里扔一些意大利面条”近乎疯狂的编程、暑假与《操作系统：设计和执行》在床上度过；开发自己的操作系统取代原先自己使用的MINIX，并将其个放在网络上供人们自由下载；来到硅谷加入Transmeta后的生活等等。</p>

<p>   最让人印象深刻的是，Linus对名誉和利益的追求基本为0，凭借他的才智和能力，完全可以达到与Gates等人的地位，但是Linus所做的这一切都是为了一个简简单单的目的，即自己的兴趣，这也正是本书的主题：一切为了兴趣。(Just for fun！)</p>

<p>   同时Linux也是通过网络开发开源软件的典范，为开源（Open Source）以及自由软件联盟(FSF)的发展做出了极大的贡献。当然，开源并不意味着可以滥用，这里有牵扯到了知识产权、专利以及开源的相关概念，我们可以通过Google了解他们的区别与联系。包括《黑客与画家》涉及到开源方面观点的书都会谈到一些这样的话题，比如开源与专利是不矛盾的等等。</p>

<p>   这一类书（自传类的，还有《世界因你不同》之类的）读起来很快，而且很励志，看到伟人的生活与工作的历程总感觉有一股热量从身体中迸发出来。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Try to use ORANGE: Classification]]></title>
    <link href="/2012-11-try-to-use-orange-classification/"/>
    <updated>2012-11-07T11:18:00+08:00</updated>
    <id>/try-to-use-orange-classification</id>
    <content type="html"><![CDATA[<h3>环境</h3>

<hr />

<p>Kubuntu 12.04/Python 2.7.3/Orange 2.0b</p>

<h3>准备工作</h3>

<hr />

<pre><code>#1.下载Orange的源码和Numpy的源码
#2.编译Numpy
#3.安装Python开发包
sudo apt-get install python-dev
#4.安装Python networkx包
sudo apt-get install python-networkx
#5.编译Orange
python install.py build
</code></pre>

<h3>测试</h3>

<hr />

<pre><code>import orange
#导入orange
orange.version
'2.0b (21:58:41, Nov 3 2012)'
</code></pre>

<h3>Classification</h3>

<hr />

<p>从<a href="http://archive.ics.uci.edu/ml/">UCI Machine Learning Repository</a>下载一个测试数据集；比如Voting.tab</p>

<h4>Naive Bayes classifier</h4>

<pre><code>import orange
data = orange.ExampleTable("voting")
classifier = orange.BayesLearner(data)
for i in range(5):
    c = classifier(data[i])
    print("original",data[i].getclass(),"classified as ",c)
</code></pre>

<p>输出结果</p>

<pre><code>original republican classified as  republican
original republican classified as  republican
original democrat classified as  republican
original democrat classified as  democrat
original democrat classified as  democrat
</code></pre>

<p>可以看出，Naive Bayes在第三个实例处出现了错误，但是其他的都是正确的。</p>

<pre><code>import orange
data = orange.ExampleTable("voting")
classifier = orange.BayesLearner(data)
corrcetNum = 0
#计数器
for i in data:
    a = i.getclass()
    b = classifier(i)
    if a == b:
        corrcetNum += 1

print "CA:%.3f" %(float(corrcetNum)/len(data))
#计算分类正确率
#输出结果
Possible classes: &lt;republican, democrat&gt;
CA:0.9034
</code></pre>

<p>可见，Naive Bayes在数据量比较大的时候分类的正确率还是比较高的。</p>

<h4>参考资料</h4>

<hr />

<ul>
<li>Orange reference : <a href="http://orange.biolab.si/doc/reference/">http://orange.biolab.si/doc/reference/</a></li>
<li>Orange tutorial : <a href="http://orange.biolab.si/doc/tutorial/">http://orange.biolab.si/doc/tutorial/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[随笔一篇]]></title>
    <link href="/2012-10-sui-bi-yi-pian/"/>
    <updated>2012-10-22T22:25:00+08:00</updated>
    <id>/sui-bi-yi-pian</id>
    <content type="html"><![CDATA[<p>不知道从什么时候开始，在身边很多人眼里，使用Linux 的人开始变成了装逼的代名词。</p>

<p>这以至于每当我在捣鼓自己的Kubuntu的时候，总会有无聊的声音传到耳蜗里。其中大多数都是根本不了解Linux的，以至于他们越说话就让我越觉得他们很无知;但是其实最让人感到郁闷的是那些懂一点相关知识的，有些是在自己的电脑上用过Ubuntu虚拟机的，有些是自认为对电脑很了解的，而有些是用过一段时间Linux无疾而终的。</p>

<p>为什么说这是最让人感到郁闷的呢？因为其实我一直都是觉得讨论操作系统优劣问题这个话题，以及编程语言优劣问题都是十分徒劳的：一个难当大任的操作系统或者编程语言在历史的进程中自然而然的会被淘汰，尤其是在现在这样一个科技日新月异的时代，所以就算各个“帮派”之间再怎么争破喉咙也是无济于事，不然Java作为一门饱受攻击的语言怎么还会有那么多程序员“不离不弃”呢？！</p>

<p>以下列举几个自己遇到的比较典型的情景。</p>

<ul>
<li><p>情景1-“Kubuntu啊，一听名字就是山寨的。” 不好意思，不知道是从哪里听   出来一点点山寨的意思的。请问你知道Kubuntu为什么叫Kubuntu么？那么比如他的名字是Xubuntu呢，也山寨么？你知道Ubuntu默认的是GNOME？Unity？你知道Linux有哪些桌面么？KDE？XFCE？LXDE？那么关于其他诸如Mint/Suse/Fedora/Arc等Linux发行版也就不用说了。举这个例子只是想说明一个问题：不能因为只听说过RedHat/Debian/Ubuntu这些有名的发行版就把自己的认知限于这一小隅，这好比去过外滩看过东方明珠和在建的上海中心却不知道上海还有田子坊这样的地方。</p></li>
<li><p>情景2-“为什么用Kubuntu啊，界面好看么？我觉得还没Win7好看呢。”的确，Win7的aero效果的确不错啊，就用户体验而言可以算是操作系统的一个典范;当然我不想纠结于操作系统的优劣之辩，不过前一句话后肯定跟着很多个“但是”。仅针对这个情景而言，我只能说我对于界面的要求没那么高，不然就去折腾KDE的3D界面效果了，听说很炫，怎么着也不会比Win7差吧，不过我还从未尝试过，觉得没有必要。</p></li>
<li><p>情景3-“Linux有什么好的，虚拟机跑跑还不够啊”其实我一直都觉得在虚拟机里跑的系统都是那些用户自己不会想去安装继而长期使用的。其实这又何异于超市里的免费品尝呢？需要买的东西自然会去选择、购买、长期拥有，但是有些对有些东西的需要只停留在试尝的程度。对于一个满心希望在Linux环境下学习工作娱乐的人，为什么要忍受win下的虚拟机呢？！</p></li>
<li><p>情景4-“你看，又装逼用Linux了，Linux有什么好用的啦。”首先，我觉得用Linux并没有什么可以用来装逼的资本，就如同围脖之于大众，豆瓣之于小众一样，Windows可以说是OS里的大众，那Linux也无非是一小众;我喜欢Linux胜过Windows，就像我喜欢豆瓣胜过微博一样。都是个人的选择，难道有人会在对方玩豆瓣的时候吐槽一句么？！</p></li>
</ul>


<p>从大一开始第一次接触到Linux到现在，以及受到包括ESR/RMS等的思想的熏陶，我才意识到自由软件运动与开放源代码的重要性和历史意义；虽然我还尚处于起步的阶段，而且也没有进入到狂热的状态，所以学习的进度可以说比较缓慢，直到这学期由于课程比较少才有了大把的时间来看书和实践，以及在LinuxToy/Study-Area/ChinaUnix等网站上久久流连和在王垠/ESR等人的文章上从钦佩到赞许。</p>

<p>最后，推荐几个网址：<br/>
* LinuxToy上的开源世界旅行手册：<a href="http://i.linuxtoy.org/docs/guide/">http://i.linuxtoy.org/docs/guide/</a><br/>
* Study-Area上的GNU/Linux学习之旅：<a href="http://www.study-area.org/tips/linux_entry.htm">http://www.study-area.org/tips/linux_entry.htm</a><br/>
* 王垠的wiki站和新浪博客：<a href="http://docs.huihoo.com/homepage/shredderyin/">http://docs.huihoo.com/homepage/shredderyin/</a><br/>
<a href="http://blog.sina.com.cn/yinwang0">http://blog.sina.com.cn/yinwang0</a><br/>
* joyfire的Linux笔记 <a href="http://man.lupaworld.com/content/develop/joyfire/">http://man.lupaworld.com/content/develop/joyfire/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Experience of Using Bootstrap]]></title>
    <link href="/2012-10-experience-of-using-bootstrap/"/>
    <updated>2012-10-16T11:15:00+08:00</updated>
    <id>/experience-of-using-bootstrap</id>
    <content type="html"><![CDATA[<p>最近在捣鼓一个网站，然后也是第一次用到前端框架——bootstrap（详细关于bootstrap的信息参阅<a href="http://twitter.github.com/bootstrap/%EF%BC%89">http://twitter.github.com/bootstrap/%EF%BC%89</a>）</p>

<ul>
<li>使用bootstrap的感受</li>
</ul>


<p>    个人用起来感觉还不错，提供了很多平时建站时需要的组件如：按钮、导航栏、标签等；JS插件如：对话框、弹出提示、下拉项、输入提示等。
    在构建页面的时候只要稍稍修改一下CSS，并配合自己构建的HTML就可以作出比较好的效果。
    特别喜欢twitter的界面风格的同学可以尝试着用来创建相似界面风格的网站前台页面。而且个人觉得也比较小清新 : )</p>

<p>    记得是在知乎上看到对bootstrap的不满意，认为bootstrap制约了他的构建，并且推荐了另一个前端框架：foundation
个人暂时还没有用过，但是打算在下一次的时候尝试一下这个被称之为“更好的”框架。</p>

<ul>
<li>关于Jetstrap</li>
</ul>


<p> 这个工具有个视频介绍之：<a href="http://v.youku.com/v_show/id_XNDU0ODM5OTQw.html">http://v.youku.com/v_show/id_XNDU0ODM5OTQw.html</a></p>

<p>    我们也许可以称之为"网页版的构建纯bootstrap页面的Dreamweaver"。
用户可以通过Google、Twitter或者Github账户登录到这个站点上，免费给用户使用（据说未来可能收费），这里的所有组件都是可以拖拽的，可以通过用户自定义CSS进行一些细微的改变，并可以将HTML和CSS打包成zip文件，方便开发站点的前台页面。</p>

<p>    不过个人还是不喜欢这一类（可视化的）工具，当然也包括了Dreamweaver，反而喜欢用SublimeText2或者Emacs来写。当然，这纯属个人喜好，并不是说用可视化工具有什么不好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nexus 7 连接 Linux]]></title>
    <link href="/2012-10-nexus-lian-jie-linux/"/>
    <updated>2012-10-12T11:15:00+08:00</updated>
    <id>/nexus-lian-jie-linux</id>
    <content type="html"><![CDATA[<p>地址：<a href="http://archboy.org/2012/09/17/linux-connect-google-nexus-7-file-system-adb-development/">http://archboy.org/2012/09/17/linux-connect-google-nexus-7-file-system-adb-development/</a></p>

<p>Problem occured:</p>

<pre><code>$ sudo pacman -S libmtp mtpfs
</code></pre>

<p>在执行这条命令的时候出现了</p>

<pre><code>No protocol specified

No protocol specified

no display possibled
</code></pre>

<p>不过不影响接下来的步骤。</p>

<p>有趣的是，pacman就是“吃豆子”游戏……可以在终端中输入后玩 : )</p>
]]></content>
  </entry>
  
</feed>
